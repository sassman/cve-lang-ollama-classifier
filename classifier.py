#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# This classifier iterates over all CVE files and classifies them.
# The classification via ollama provides the cveId, the programming language and the reasoning.

import os
import argparse
import ollama
import glob
import json


def classify_one_cve(cve_file, model):
    print(f"[*] Classifying {cve_file} ...")
    response = ollama.chat(model=model, messages=[
        dict(
            role="user", content=cve_classification_prompt(cve_file=cve_file)
        )
    ])

    json_fenced = response['message']['content']
    json_unfenced = json_fenced[json_fenced.find('```json')+len('```json'):json_fenced.rfind('```')]
    try:
        classification = json.loads(json_unfenced)
        # this ensures a stable structured output
        return dict(
            programming_language=classification.get('programming_language').lower(),
            # todo: verify it relly corresponds to the cve id from the given file
            cve_id=classification.get('cve_id'),
            reasoning=classification.get('reasoning')
        )
    except json.JSONDecodeError as e:
        print(f"  [-] Error: Could not decode JSON: {json_fenced}")
        return None


def cve_classification_prompt(cve_file):
    example_output = """{
    "programming_language": "Java",
    "cve_id": "CVE-2024-40322",
    "reasoning": "<resoning goes here>"
}
"""
    with open(cve_file, 'r') as file:
        cve = file.read()

    return f"""Given the following CVE:
```json {cve_file}
{cve}
```
please clasify the programming language this CVE is relates to?

Please provide the response structure with only 3 fields, no further text
- `programming_language` e.g. like java, py, c as their file extension in lower case. Unclear cases should be called `unknown`
- `cve_id` with the value of the CVE id like `CVE-2024-40322`
- `reasoning` with a longer reasoning

like this:
```json
{example_output}
```
"""


def classify(args):
    model = args.model
    cve_dir = args.cve_dir
    classification_ext = '_classification.json'

    for cve_file in glob.iglob(f'{cve_dir}/**/CVE*.json', recursive=True):
        if cve_file.endswith(classification_ext):
            continue
        classification_file = cve_file.replace('.json', classification_ext)
        if os.path.exists(classification_file):
            print(f"  [-] [Skip] Classification already exists: {classification_file}")
            continue
        classification = classify_one_cve(cve_file, model)
        if classification is not None:
            print(f"  [-] Programming Language: {classification.get('programming_language')}")
            with open(f'{classification_file}', 'w+') as file:
                json.dump(classification, file, ensure_ascii=False, indent=4)
            print(f"  [-] Classification saved to {classification_file}")
        else:
            print(f"  [-] Error: Classification failed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('--cve-dir', default="cvelistV5-main/cves", help='Directory containing the CVE files')
    parser.add_argument('--model', default="gemma2", help='Model to use for classification')
    parser.add_argument('--verbose', action='store_true', help='Verbose mode')

    args = parser.parse_args()
    classify(args)
